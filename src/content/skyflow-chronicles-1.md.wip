---
titlePlain: "Skyflow"
titleColor: "Chronicles"
excerpt: "Building a social analytics platform"
cardImg: "/assets/img/blog/sicilian-bytes-bear.jpeg"
coverImg: "/assets/img/blog/sicilian-bytes-olives.png"
date: "2024-05-20T19:35:07.322Z"
tags: ["programming", "cuisine", "coding", "cooking", "sicily"]
intro: "Embarking on a coding journey is like entering a kitchen filled with diverse, endless ingredients."
author:
    name: Alex Arno
    avatar: "/assets/img/hero/hero-lakes-headshot.png"
---

# Building Skyflow: A Journey Through Social Analytics Engineering

When I first started building Skyflow, I had a simple goal: make sense of the noise in my Bluesky feed. Little did I know this would turn into a deep dive into asynchronous programming, service architecture, and the intricacies of social data analysis.

## The Challenge

Building a social analytics platform isn't just about counting likes and replies. It's about creating a system that can:

1. Handle authentication securely
2. Process large amounts of social data efficiently
3. Store and retrieve insights quickly
4. Present data in meaningful ways

And all of this needs to happen in near real-time while remaining scalable.

## Technical Architecture Decisions

### Why FastAPI?

The choice of FastAPI wasn't just about speed (though it's blazingly fast). It was about building a modern API that could handle asynchronous operations elegantly. Here's a simple example of how clean the code looks:

```python
@app.post("/")
async def timeline_endpoint(
    request: Request,
    handle: str = Body(...),
    password: str = Body(...)
) -> JSONResponse:
    # Handle requests asynchronously
```

### The Service Layer Pattern

One of the most important architectural decisions was implementing a clear service layer pattern. Each major feature (Flow, Clout, Kudos, Pulse) has its own service:

```python
from core.services.bsky_service import new_bluesky_service
from core.services.clout_service import new_clout_service
from core.services.kudos_service import new_kudos_service
from core.services.flow_service import new_flow_service
```

This separation of concerns makes the code more maintainable and testable.

## Lessons Learned

### 1. Data Structure Matters

Initially, I structured the engagement data as a flat array. Big mistake. Processing time grew exponentially with data size. The solution? A clever timestamp-based grouping:

```python
def construct_flow_data(flow_posts: dict, user_did: str, timestamp: datetime):
    points = []
    presence_count = {}
    for timestamp, posts in flow_posts.items():
        timestamp_score = sum(
            post["likes"] + post["replies"] + post["reposts"]
            for post in posts
        )
```

### 2. Async Context Management is Crucial

One of the most elegant solutions in the codebase is the database connection management:

```python
@asynccontextmanager
async def lifespan(app: FastAPI):
    global mongo_client
    mongo_client = MongoClient()
    db = await mongo_client.ping()
    app.db = db
    yield
    await mongo_client.close()
```

This ensures proper resource cleanup and efficient connection management.

### 3. Error Handling is an Art

The error handling approach evolved significantly during development. The current implementation provides detailed error feedback while maintaining security:

```python
except HTTPException as http_exc:
    return JSONResponse(content={
        "ok": False,
        "status": "error",
        "detail": http_exc.detail,
    }, status_code=http_exc.status_code)
```

## The Road Ahead

Building Skyflow has been a journey of continuous learning. The current version is just the beginning. Future plans include:

-   Real-time analytics processing
-   Machine learning for trend prediction
-   Enhanced data visualization options

Remember, every great project starts with a simple problem and grows through iteration and learning. Keep building, keep learning, and most importantly, keep sharing what you learn with others.
